package model;

//
/*A Model specific for stations
 * 		1)contains methods to get and set variables
 * 		2)contains methods to create a unique ID
 * 		3)Overrides delete(), so that it is not delete-able in it;s .csv file
 * 
 * 
 * Contains:
 * ID, name, description, address, phone, activated
 * 
 * The following are user inputed:
 * name, description, address, phone, activated
 * 
 * The following are generated by class:
 * ID
 * 
 * @deprecated equals(Object), method not used
 */

import java.io.*;
import java.util.LinkedList;
import java.util.StringTokenizer;

public class Station extends Model {

	//attributes
	private String name;
	private String description,address;
	private String phone;
	private boolean activated;
	
	public Station() throws IOException
	{
		this(null);
	}
	
	public Station(Integer id) throws IOException
	{
		super("station.csv",id);
	}
	
	//method used to set all attribute values with string
	@Override
	public void set(String key, Object value) {
		if (key.equals("id"))
			id=Integer.parseInt("" + value);
		else if (key.equals("name"))
			name=(String)value;
		else if (key.equals("description"))
			description=(String)value;
		else if (key.equals("address"))
			address=(String)value;
		else if (key.equals("phone"))
			phone=(String)value;
		else if (key.equals("activated"))
			activated=(""+value).equals("true")||(""+value).equals("yes");
	}

	//returns a Model[] of all Models found in it's .csv file that are activated
	//specfic loading for stations
	public Model[] loadAllActivated() throws IOException
	{
		BufferedReader br = new BufferedReader(new FileReader(filename));
		String line = br.readLine();
		loadFields(line);
		LinkedList<Model> models = new LinkedList<Model>();
		line = br.readLine();

		// loop through lines.
		while (line!=null)
		{  
			Model m = (Model)this.createNew();
			StringTokenizer st = new StringTokenizer(line,",\r\n");
			if (st.countTokens()!=fields.keySet().size())
				break;

			int index=0;

			// loop through all fields.
			while (st.hasMoreTokens())
			{
				m.set(fields.get(index),st.nextToken());
				index++;  
			}
			m.loaded=true;
			m.fields=this.fields;
			if (("" + m.get("activated")).equals("true"))
			{
				models.add(m);
			}
			
			line = br.readLine();  
		}	//@Override
		br.close();

		return models.toArray(new Model[models.size()]);
	}
	
	//method used to get all attribute values as a String
	@Override
	public Object get(String key) {
		if (key.equals("id"))
			return id;
		else if (key.equals("name"))
			return name;
		else if (key.equals("description"))
			return description;
		else if (key.equals("address"))
			return address;
		else if (key.equals("phone"))
			return phone;
		else if (key.equals("activated"))
			return activated;
		else
			throw new IllegalArgumentException("Invalid key: "+key);
	}

	@Override
	protected Model createNew() {
		try{
			return new Station();
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
		}
		return null;
	}

	//Override delete method, to not allow it to happen
	@Override
	public void delete()
	{
		System.out.println("ATTEMPT AT DELETING STATION, SHOULD NOT SEE THIS");
	}
	
	public boolean isActivated()
	{
		return activated;
	}
	public String toString()
	{
		return ("ID: " + id +
				" Name: " + name +
				" Description: " + description +
				" Address: " + address +
				" Phone: " + phone +
				" Activated Status: " + activated );
	}
	//checks if the ID's are equals, which means that they should be the same
	//may cause complications if used with different Model Types
	@Deprecated
	public boolean equals(Object o)
	{
		return (o instanceof Station)&&(((Station)o).id==this.id);
	}
}
